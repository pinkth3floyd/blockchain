import { createHash } from 'crypto';


const sha256 = (data: string): string => {
    return createHash('sha256').update(data).digest('hex');
};


export class MerkelTransaction {
    constructor(
        public readonly sender: string,
        public readonly receiver: string,
        public readonly amount: number
    ) {}

    
    calculateHash(): string {
        return sha256(this.sender + this.receiver + this.amount);
    }
}


export class MerkleNode {
    constructor(
        public readonly value: string,
        public readonly left?: MerkleNode,
        public readonly right?: MerkleNode
    ) {}
}


export class MerkleTree {
    root: MerkleNode | null = null;

    constructor(public transactions: MerkelTransaction[]) {
        this.buildTree();
    }

   
    buildTree(): void {
        if (this.transactions.length === 0) {
            this.root = null;
            return;
        }

        const transactionHashes = this.transactions.map(transaction => transaction.calculateHash());
        this.root = this.build(transactionHashes);
    }

    
    private build(nodes: string[]): MerkleNode {
        if (nodes.length === 1) {
            return new MerkleNode(nodes[0]);
        }

        const parentNodes: MerkleNode[] = [];
        for (let i = 0; i < nodes.length; i += 2) {
            const left = new MerkleNode(nodes[i]);
            const rightValue = i + 1 < nodes.length ? nodes[i + 1] : nodes[i];
            const right = new MerkleNode(rightValue);
            const combinedHash = sha256(left.value + right.value);
            parentNodes.push(new MerkleNode(combinedHash, left, right));
        }
        const nextLayer = parentNodes.map(node => node.value);
        return this.build(nextLayer);
    }

    // Gets the root hash of the Merkle Tree
    getRootHash(): string {
        return this.root ? this.root.value : '';
    }

      // Verifies a transaction is in the Merkle Tree.  Returns the Merkle proof.
    verifyTransaction(transaction: MerkelTransaction): string[] | null {
        if (!this.root) return null;

        const targetHash = transaction.calculateHash();
        const proof: string[] = [];
        return this.findProof(this.root, targetHash, proof);
    }

    private findProof(node: MerkleNode, targetHash: string, proof: string[]): string[] | null {
        if (node.value === targetHash) {
            return proof;
        }

        if (node.left) {
            const leftProof = [...proof, node.right ? node.right.value : ''];
            const result = this.findProof(node.left, targetHash, leftProof);
            if (result) return result;
        }

        if (node.right) {
             const rightProof = [...proof, node.left ? node.left.value: ''];
            const result = this.findProof(node.right, targetHash, rightProof);
            if (result) return result;
        }
        return null;
    }

    //Checks the proof that is generated by verifyTransaction
    checkProof(targetHash:string, proof: string[], rootHash:string):boolean{
        if(proof.length === 0 && sha256(targetHash) === rootHash){
            return true;
        }

        let hash = targetHash;
        for(let i = 0; i< proof.length; i++){
            const node = proof[i];
            if(node){
                hash = sha256(hash < node ? hash + node : node + hash); //order
            }
        }
        return hash === rootHash;
    }
}



export class MerkelBlock {
    constructor(
        public readonly index: number,
        public readonly previousHash: string,
        public readonly timestamp: number,
        public merkleRoot: string, // Store the Merkle Root instead of raw data
        public readonly transactions: MerkelTransaction[], // Store the transactions
        public readonly hash: string
    ) { }

    calculateHash(): string {
        return sha256(this.index + this.previousHash + this.timestamp + this.merkleRoot + JSON.stringify(this.transactions));
    }

    static createGenesisBlock(): MerkelBlock {
        const genesisBlock = new MerkelBlock(0, "0", Date.now(), "0", [], "0");
        const genesisBlockHash = genesisBlock.calculateHash();
        return new MerkelBlock(0, "0", genesisBlock.timestamp, "0",[], genesisBlockHash);
    }
}


export class MerkelBlockchain {
    public chain: MerkelBlock[];

    constructor() {
        this.chain = [MerkelBlock.createGenesisBlock()];
    }

    getLatestBlock(): MerkelBlock {
        return this.chain[this.chain.length - 1];
    }

    addBlock(transactions: MerkelTransaction[]): void {
      const previousBlock = this.getLatestBlock();
      const newIndex = previousBlock.index + 1;
      const newTimestamp = Date.now();
      const merkleTree = new MerkleTree(transactions);
      const merkleRoot = merkleTree.getRootHash();
      const newHash = sha256(newIndex + previousBlock.hash + newTimestamp + merkleRoot + JSON.stringify(transactions));
      const newBlock = new MerkelBlock(newIndex, previousBlock.hash, newTimestamp, merkleRoot, transactions, newHash);
      this.chain.push(newBlock);
    }

    isChainValid(): boolean {
        if (this.chain.length === 1) return true;

        for (let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];

            if (currentBlock.previousHash !== previousBlock.hash) {
                console.error(`Previous hash mismatch at block ${i}`);
                return false;
            }

            const calculatedHash = currentBlock.calculateHash();
            if (currentBlock.hash !== calculatedHash) {
                console.error(`Hash mismatch at block ${i}`);
                return false;
            }
        }
        return true;
    }

      getChain(): MerkelBlock[] {
          return this.chain;
      }
}



